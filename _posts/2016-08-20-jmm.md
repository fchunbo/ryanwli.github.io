---
layout:     post
title:      "浅谈Java内存模型"
subtitle:   "虽然JSR-133在2004年就给出了Java内存模型和线程规范，但是我在这里依然还是要写这个内容，其目的为了加深自己在这块的理解，另外就是让公司团队也强化一下在多线程上面的造化。"
date:       2016-08-20 16:17:00
author:     "ryan"
header-img: "img/post-bg-06.jpg"
---


# 序言
我们还是稍微增加一些门槛，怎么使用java多闲的类和关键字，以及每个关键字的含义，这里就不多做讲解，必定这个属于java基础，本章的内容都是界定大家都已经熟悉java并发编程基础展开的讲解。废话不多说直接上代码：

```java
public class VolatileExample {
	 int x = 0;
	 int y = 0;
	 int a = 0;
	 int b = 0;
	
	
	public void go() throws Exception {
	    Thread one = new Thread(new Runnable() {
	        public void run() {
	            a = 1;
	            x = b;
	        }
	    });

	    Thread other = new Thread(new Runnable() {
	        public void run() {
	            b = 1;
	            y = a;
	        }
	    });
	    one.start();other.start();
	    one.join();other.join();
    	if (x == 0 && y == 0) {
    		System.out.println("(" + x + "," + y + ")");
    	} else if (x == 1 && y == 1) {
    		System.out.println("(" + x + "," + y + ")");
    	}
	}
}
```

执行go方法，在one thread和other thread跑完后(该机器处理器型号Intel(R) Xeon(R) CPU E5-2430，为什么要说明处理，后面的内容会说，这个很重要)，我们会得到(0,1), (1,0), (0,0)这三个结果，这里我们就产生几个疑问了：

1.为什么没有(1,1)的结果？

2.安程序的之心顺序应该是(0,1)才会，为什么又多出来(1,0)，(0,0);

带着这些疑问我们开始讲解我们今天的内容

# Java线程调度





# 重排序





# 可见性





# volatile







# Memory Barriers







# Happens-before





# synchronized





# reetrantlock







# final





# 总结

