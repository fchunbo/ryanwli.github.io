---
layout:     post
title:      "Java 8"
subtitle:   "Java8发布了很长一段时间了，但是我们团队还处于习惯Java7的编程思维和习惯，该篇文章会让大家尽快的了解Java8有哪些新特性，以及如何应用到我们的工作中去。"
date:       2017-05-18 12:30:00
author:     "ryan"
header-img: "img/post-bg-04.jpg"
---

# 前言

Java8发布了很长一段时间了，但是我们团队还处于习惯Java7的编程思维和习惯，该篇文章会让大家尽快的了解Java8有哪些新特性，以及如何应用到我们的工作中去。

函数式编程很早就出来，比Java后出来的C#语言，早在10年的.NET 4.0的版本就加入lambda表达式，来提供函数式编程，并且提供基于函数式的流方式的并行处理的功能。所以 Java算是比较迟缓的了(整整晚了4年时间)，在2014年采正式推出Java8来支持这一特性。

什么是函数式编程，首先里面的函数，不是我们Java平时说的方法，他更加严格意义上的来说是一个数学上的函数(如：Math类下面的一些静态方法)，一个函数的公式，这个公式对于指定输入，然后到输出是稳定，意思就是说你多次输入什么值必定就会多次得到同样的结果；那么这就意味着函数里面计算过程没有外界共享变量来影响函数的计算；在函数式编程中，一个lambda表达式(也就是一个函数)，可以享有和值一样的待遇，可以作为方法的参数进行传递，这样在Java8里面就可以简化很多的代码并易于理解；另外函数类是不会有共享变量的操作，或者说共享变量的操作对函数的输出稳定是没有影响的，这样的好处是对于无共享状态的操作，更容易写出并行代码，因为没有共享资源的同步争夺等开销。



# 1. lambda表达式

这一节，主要来说一下Java8 lambda表达式的基础，以及如果利用lambda表达式来体现函数式编程给代码带来的更接近自然语言的简洁，易于理解和维护的；

## 1.1 初见

我们就从我们最常用的自定义列表排序来说起，下面是Java8以前我们的写法：

```java
List<Integer> list = Arrays.asList(3, 2, 1);
Collections.sort(list, new Comparator<Integer>() {
	@Override
	public int compare(Integer o1, Integer o2) {
		return o1.compareTo(o2);
	}    		
});
```

现在Java8的写法：

```java
List<Integer> list = Arrays.asList(3, 2, 1);
list.sort((p1,p2) -> p1.compareTo(p2));
```

这种将行为进行参数话，在Java8以前只能依靠匿名局部类来实现，首先我们单纯从语法上面来看，但是创建了刚定义好的类的实例来进行传参的，传递的还是一个值，该值代表一个对象引用地址。从新的Java8把行为作为参数进行传递，这个行为而且使用了非常简洁的一个函数表达式就搞定了；以前3行代码，现在一行代码，对于阅读来说也是非常惬意的。

## 1.2 自定义lambda表达式

lambda表达式也需要有一个接口规范来定义的，不是说想在哪用就在哪用，下面我们来看看如何定义lambda接口，以及怎么使用：

```java
//定义lambda接口
@FunctionalInterface
public interface ITest {
    String test();
}
//使用该接口
public void print(ITest test) {
    System.out.println("hello, " + test.test());
}
//使用该方法
print(()=> "ryan");
```

lambda在Java中de定义是沿用了之前Java版本的接口，并且一个接口里面只能有一个方法，@FunctionalInterface注解是一个描述注解，用于Java8的Javac做这种一个接口里面只能有一个方法的lambda接口的检查；

## 1.3 系统与定义的lambda接口

除了上面看到的自己定义lambda接口以外，系统其实已经内置许多接口，请看下表：

| 函数式接口               | 函数描述符             | 原始类型特化                                   |
| ------------------- | ----------------- | ---------------------------------------- |
| `Predicate<T>`      | T -> boolean      | IntPredicate, <br>LongPredicate, <br>DoublePredicate |
| `Consumer<T>`       | T -> void         | IntConsumer, <br>LongConsumer, <br>DoubleConsumer |
| `Function<T,R>`     | T -> R            | `IntFunction<R>`,  <br>IntToDoubleFunction, <br>IntToLongFunction, <br>`LongFunction<R>`, <br>LongToDoubleFunction, <br>LongToIntFunction, <br>`DoubleFunction<R>`, <br>`ToIntFunction<T>`, <br>`ToDoubleFunction<T>`, <br>`ToLongFunction<T>` |
| `Supplier<T>`       | () -> T           | BooleanSupplier, <br>IntSupplier, <br>LongSupplier, <br>DoubleSupplier |
| `UnaryOperator<T>`  | T -> T            | IntUnaryOperator, <br>LongunaryOperator, <br>DoubleUnaryOperator |
| `BinaryOperator<T>` | (T,T) -> T        | IntBinaryOperator, <br>LongBinaryOperator, <br>DoubleBinaryOperator |
| `BiPredicate<L, R>` | (L, R) -> boolean |                                          |
| `BiConsumer<T, U>`  | (T, U) -> void    | `ObjIntConsumer<T>`, <br>`ObjLongConsumer<T>`, <br>`ObjDoubleConsumer<T>` |
| `BiFunction<T,U,R>` | (T, U) -> R       | `ToIntBiFunction<T, U>`, <br>`ToLongBiFunction<T, U>`, <br>`ToDoubleBiFunction<T, U>` |

有了上面的预定的lambda接口，我们可以将1.2的例子修改为如下形式：

```java
//使用该接口
public void print(Supplier<String> test) {
    System.out.println("hello, " + test.test());
}
//使用该方法
print(()=> "ryan");
```

另外你们看到了一些原型类型的接口，这些还是因为Java的泛型是一个假泛型，到了class字节码那一级还是使用了Object来耍的，对于简单类型int/long/boolean来说，都会装箱成Int/Long/Boolean，这些原始类型就是解决了这些简单类型装箱和拆箱带来的性能开销。

## 1.4 Java7中常见代码应用lambda表达式

除了我上面看到的Collection.sort的改进的例子外，还有其他常用的方式，下面我们一一道来：

## 1.4.1 多线程用Runnable

```java
//老方式
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("run in java 7");
    }
}).start();

//新方式(初始化一个线程打印"run in java 8"文本，并开始执行")
new Thread(()-> System.out.println("run in java 8")).start();
```

## 1.4.2 多线程用Callable

```java
//老方式
//Callable在Java 8中的实现
Executors.newCachedThreadPool().submit(new Callable() {
  @Override
  public String call() {
    return "hello java 7";
  }
}).get();

//Callable在Java 8中的实现
Executors.newCachedThreadPool().submit(()-> "hello java 8").get();
```



## 1.4.2 迭代一个List

```java
//老方式
List<String> strings = Arrays.asList("ryan", "jimmy", "aaron");
for (String str : strings) {
	System.out.println("hello, " + str);
}
//新方式
Arrays.asList("ryan", "jimmy", "aaron").forEach(str-> System.out.println("hello, " + str));
```



## 1.5 类型推断

```java
//ex:
list.sort((Integer p1, Integer p2) -> p1.compareTo(p2));
//简写
list.sort((p1,p2) -> p1.compareTo(p2));

//ex:
Arrays.asList("ryan", "jimmy", "aaron").forEach((String str)-> System.out.println("hello, " + str));
//简写
Arrays.asList("ryan", "jimmy", "aaron").forEach(str-> System.out.println("hello, " + str));
```

1.5上面的例子都适用了简写，但是这里我们还是要说一下，这个是Java8里面根据接口定义来推断出具体类型的，所以我们可以省略掉，但是有时候加上这个类型，反而会更加醒目易于读懂；这个大部分的函数编程为了极大的减少代码量，基本都使用了该技术来实现动态化的类型推断。



## 1.6 lambda的语法糖(引用方法)

先来看一个例子：

```java
//list比较之前lambda的写法：
inventory.sort((Apple p1, Apple p2) -> p1.getWeight().compareTo(p2.getWeight()));
//使用Comparator接口comparing静态方法简化，上面的写法：
inventory.sort(Comparator.comparing((Apple p) -> p.getWeight));
//使用lambda的语法糖再进行简化写法：
inventory.sort(Comparator.comparing(Apple::getWeight));
```

再看看下面的例子：

|                  Lambda                  |              等效的方法引用              |
| :--------------------------------------: | :-------------------------------: |
|        (Apple a) -> a.getWeight()        |         Apple::getWeight          |
| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
|       (str, i) -> str.substring(i)       |         String::substring         |
|   (String s) -> System.out.println(s)    |        System.out::println        |

看了这些例子后，这其中是有规则的，主要有三类：

(1)指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。

(2)指向任意类型实例方法的方法引用（例如String的substring，写作String::substring）。

(3)指向现有对象的实例的方法引用（假设你有一个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensiveTransaction::getValue）



# 2. 流式处理

我们还是先来看一个例子，来说明Java8中的流在解决什么问题：

这个例子是提取一个复杂类型列表中名字的字符串列表，Java8之前的方案

```java
List<Apple> inventory = Arrays.asList(new Apple(80,"apple1"),
        new Apple(155, "apple2"),
        new Apple(120, "apple3"));
List<String> names = new ArrayList<String>();
for (Apple apple : inventory) {
    names.add(apple.getName());
}
```

在Java8可以使用Stream来做：

```java
List<Apple> inventory = Arrays.asList(new Apple(80,"apple1"),
        new Apple(155, "apple2"),
        new Apple(120, "apple3"));
List<String> names = inventory.stream().map(Apple::getName).collect(toList());
```

也是一句话的功夫就完成了列表的转换，stream是对一个数据流的进行生产线方式的链式处理，上面用了map，以及collect只是stream其中的方法。stream中的处理分为两大类，一类叫中间操作，一类叫终端操作；

## 2.1 中间操作方法：

|    操作    |       操作参数       |      函数描述       |                    输入                    |                   例子                   |                输出                |
| :------: | :--------------: | :-------------: | :--------------------------------------: | :------------------------------------: | :------------------------------: |
|  filter  |  `Predicate<T>`  |  T -> boolean   |              list={1,2,2,3}              |         list.filter(p -> p=2)          |      list={2,2}, 返回类型Stream      |
|   map    | `Function<T, R>` |     T -> R      | list={app1={name='app1'}, app2={name='app2'}} |        list.map(a -> a.getName)        | list={'app1','app2'}, 返回类型Stream |
|  limit   |                  |                 |              list={1,2,2,3}              |             list.limit(2)              |      list={1,2}, 返回类型Stream      |
|  sorted  | `Comparator<T>`  | (T, T) ->   int |              list={2,1,3,2}              | list.sort((p1,p2) -> p1.compareTo(p2)) |    list={1,2,2,3}, 返回类型Stream    |
| distinct |                  |                 |              list={1,2,2,3}              |            list.distinct()             |     list={1,2,3}, 返回类型Stream     |

## 2.2 终端操作方法：

|   操作    |  类型  |                    目的                    |
| :-----: | :--: | :--------------------------------------: |
| forEach |  终端  | 消费流中的每个元素并对其应用lambda。这操作范围void。<br>ex: streamlist.forEach(p -> System.out.println(p)) |
|  count  |  终端  | 返回流中元素的个数。这一操作返回long。<br>ex: int count =streamlist.count(); |
| collect |  终端  | 把流归约成一个合集，比如List，Map。上面我们就把`Stream<String>`变成了`List<String>` |

如何判断一个操作是否是中间操作，还是终端操作，这个就看他是否返回的是Stream，返回Stream就是中间操作。说到这里我们是否似成相识，缺失在大数据处理的分布框架Spark的RDD就是这个Stream概念，里面的转换操作就是这里的中间操作，里面的行动操作就是这里的终端操作；





流在遍历的时候智能遍历一次





# 3. default方法



# 4. Optional



